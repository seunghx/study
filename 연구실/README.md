## 연구실
2017.03 ~ 2018.01 까지의 기간 동안 가톨릭대학교 소프트웨어공학 연구실에서 연구 보조 과정 중 
참여한 논문 또는 과제 중 일부(현재 그나마 갖고있는 것들)를 저장.

---


   - [자바 웹 앱에서 웹 컴포넌트와 웹 자원의 의존 관계를 자동으로 추출하는 기법] 논문 참여

    - let [논문 1] = 서블릿 Filter와 ServletRequestWrapper를 이용하여 자바 웹 컴포넌트(Servlet, JSP 페이지)와 그들의 의존 관계 추적 기법을 다룬 논문.

    - let [논문 2] = 제가 주도적으로 참여(아이디어 도출 및 실제 구현)하게 된 프로젝트를 기반으로 작성된 논문으로 [논문 1]을 바탕으로 설계 및 구현됨.


	가톨릭대학교 소프트웨어 공학 연구실에서 연구 보조원으로 활동하면서 '웹 컴포넌트(servlet, jsp 등) 및 웹 자원(html, css, js, image 등 정적 파일)'간의 호출 및 포함 관계로부터 유의미한 통계 정보를 추출하려는 주제의 프로젝트에 참여하였습니다. 이를 위해 [논문 1]을 기반으로 실제 Filter / Wrapper 구현을 개발하였으며 추가로 이 필터로부터 추출된 정보가 '넷 마이너'라는 그래프 관련 툴에 입력으로 사용될 수 있도록  'Apache POI'라이브러리를 이용해 엑셀 파일로 저장되도록 하였습니다.

    이 과정에서 문제가 발생하였습니다. 기존 [논문 1]의 기법은 서블릿과 JSP 간의 포함 관계와 호출(FORWARD, INCLUDE, REDIRECT)관계는 추적 가능하였으나 이미지, JS, HTML과 같은 정적 웹 자원에 대한 포함 및 호출 관계는 추적 불가능하였습니다. 처음에는 문제를 간단히 생각하여 'HTTP refer(r)er' 헤더를 이용하여 웹 자원의 호출 관계를 파악하려 하였으나 이 방법의 경우 실제로는 FORWARD 된 JSP가 호출하는 이미지 파일을 그 JSP로 요청을 FORWARD 한 서블릿이 호출한 것과 같은 잘못된 결과를 출력하였습니다. 또한 테스트용으로 사용한 open source web app 'Dream'과 같은 SPA의 경우 페이지 변경을 위한 모든 요청이 ajax를 통해 이루어지는데, 실제로는 특정 jsp에서 호출하는 정적 자원이 referrer 방식에서는 첫 페이지(가령 index.html)에서 호출된 것처럼 잘못된 결과로 출력되었습니다. (그러나 'referrer'를 사용하면 CSS파일에서 또 다른 정적 파일을 호출하는 경우에 대한 추적이 가능하다는 사실을 알 수 있었고 [논문 2] 방법의 정적 웹 자원에 대한 요청을 처리하는 필터에서 이를 이용할 수 있었습니다.) 마땅한 다른 방법이 없어 고민하던 중 기존 '[논문 1]'과 'HTTP referrer'를 이용한 방법과는 다른 보다 적극적인 방법으로 문제를 해결해보게 되었습니다.



- 아래에 설명할 방법으로 문제를 해결하려는 중 큰 실수를 범했는데 이를 통해 일년도 더 지난 현재까지도 스스로 다짐하게 되는 중요한 교훈을 얻을 수 있는 계기가 되었습니다.


	방법론을 구상하기위해 다음과 같은 가정을 세웠습니다. 
    브라우저가 html 소스 코드를 위에서부터 아래로 읽기 때문에 


#####"브라우저가 수행하는(모든)웹 요청도 위에서 아래의 순서로 이루어질 것이다."
    
	동작 방법을 구상하기에 앞서 가정이 올바른지 확실히 알아봤어야 했는데 스택오버플로우 답변만으로 확신을 갖고 아래의 방법을 구상해버렸습니다. 그러나 현대의 (복잡한)브라우저는 스택오버플로우의 답변에서 말한 것과 같이 간단하게 동작하지 않았습니다. js등의 파일은 위에서 아래로 순차적으로 요청하였으나 이미지와 같은 큰 용량의 파일의 경우 렌더링 시간을 고려하여(이미지가 로딩 시간이 오래될 경우 페이지를 구성하는 다른 요소의 렌더링이 안될 수 있기 때문에)마지막에 호출하며 ajax호출의 경우 실제 웹 요청이 언제 이루어진다는 보장이 없었습니다. Web Extension을 사용해 실제 발생한 요청을 웹 페이지 소스 코드에 등장한 순서에 맞게 reordering해보려고도 했으나 브라우저에서 이미 발생한 request를 capturing(포착)할 수는 있으나 발생한 요청을 뒤로 미루거나 없애는 방법은 Web Extension에서 제공하지 않았습니다. 결국 아래의 방법은 위의 말한 문제를 반 밖에 해결(image 파일 등에 대한 요청만 해결)하지 못했습니다. 

> 결국 이는 HTML 파서 라이브러리 등을 사용하는 방법에 크게 않다는 한계가 있습니다.

	위의 경험으로부터 처음 문제 해결 방법에 대한 가정을 세울 때 가정에 대한 검증이 매우 중요함을 깨닫게 되었습니다. 방법에 대한 가정이 옳지 않을 경우 아무리 논리적으로 방법이 잘 구상되었다고 하더라도 기대하는 올바른 결과를 낼 수 없기 때문이며 또한 잘못된 가정하에 방법을 구상했을 경우 방법이 잘못되었음을 개발이 다 진행되고 테스트를 수행하는 과정에서야 알 수 있기 때문에 시간적인 손해가 발생하기 때문입니다.

그렇게 잘못된 가정하에 구상된 아래 방법은 다음과 같습니다. (아래 이미지와 함께 보시면 이해가 편합니다.)

	ServletResponseWrapper를 이용해 HttpServletResponse 객체의 메서드를 오버라이딩하여 응답 본문을 수정할 수 있게 하였고, FORWARD, INCLUDE호출에 대한 Filter에서는 이 방법을 기반으로 각 웹 컴포넌트의 경계를 알리는 html 태그(호출 된 JSP의 정보를 attribute로 담고 있음.)를 삽입합니다. 이렇게 경계를 나타내는 태그가 삽입된 응답을 받은 프론트엔드 단에는 브라우저가 서버에 보낸 웹 요청을 포착하는 'Web Extension' 컴포넌트를 두었으며 이 컴포넌트는 브라우저에서 발생한 웹 요청을 포착하면 해당 요청이 응답 본문의 어느 위치(html 태그)에서 발생한지를 후위탐색하여 찾아냅니다. 후위 탐색을 하는 과정에 웹 컴포넌트의 경계를 알리는 html 태그를 방문하게 될 경우 해당 태그의 attribute로 부터 추출 된 JSP 등의 페이지 정보를 stack에 담아 결과적으로 브라우저에서 발생한 웹 자원에 대한 요청이 어느 JSP 또는 HTML 페이지가 호출한 것인지 추적이 가능합니다.


[](웹자원식별.png)

위에 말한 방법의 대부분의 구상과 방법에 대한 실제 구현을 직접 수행하였으며 해당 방법을 바탕으로 작성된 [논문 2]는 KCI에 등재될 수 있었습니다.
